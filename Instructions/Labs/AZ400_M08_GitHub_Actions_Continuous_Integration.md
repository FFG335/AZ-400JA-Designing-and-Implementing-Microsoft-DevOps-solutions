---
lab:
    title: 'ラボ: GitHub アクション継続的インテグレーション'
    module: 'モジュール 8: GitHub アクションとの継続的インテグレーションの実装'
---

# ラボ: GitHub アクションの継続的インテグレーション
# 学生用ラボ マニュアル

## ラボの概要

GitHub アクションは、継続的インテグレーション (CI) を GitHub リポジトリに簡単に組み込むことができます。このラボでは、ビルド プロセスを自動化する 2 つの GitHub ワークフローを設定します。

> **注**: このラボでは、**github-learning-lab** ボットを操作します。このボットは、個々のラボ タスクをガイドします。

## 目標

このラボを完了すると、次のことができるようになります。

- 継続的インテグレーションにおける GitHub アクションの重要性を説明する
- テンプレート化されたワークフローを使用およびカスタマイズする
- チームのニーズと行動に一致する CI ワークフローを作成する
- リポジトリのソース コードを使用して、ワークフロー内のジョブ全体で成果物を構築する
- GitHub アクションを使用してユニット テスト フレームワークを実装する
- テストを実行し、テスト レポートを作成するワークフローを作成する
- マトリックス ビルドを設定して、複数のターゲット プラットフォームのビルド成果物を作成する
- リポジトリのビルド成果物を保存してアクセスする
- アプリケーションの CI ニーズに合わせて仮想環境を選択する

> **注**: このラボでは、タスクの多くがビルドに関連します。これらのビルドは、ビルドに数分かかる場合があります。次のステップに進む前に、ビルドが完了するのを必ず待ってください。

## ラボの所要時間

-   推定時間: **150 分**

## 指示

### 開始する前に

#### ラボの仮想マシンにログインする

次の資格情報を使用して、Windows 10 コンピューターにサインインしていることを確認します。
    
-   ユーザー名: **Student**
-   パスワード: **Pa55w.rd**

#### このラボに必要なアプリケーションを確認する

このラボで使用するアプリケーションを特定する:
    
-   Microsoft Edge

#### GitHub アカウントを設定する

このラボで使用できる GitHub アカウントをまだお持ちでない場合は、[新しい GitHub アカウントのサインアップ](https://docs.github.com/en/free-pro-team@latest/github/getting-started-with-github/signing-up-for-a-new-github-account)にある手順に従ってください。

### 演習 1: GitHub アクションとの継続的インテグレーションを実装する

この演習では、GitHub アクションとの継続的インテグレーションを実装します

#### タスク 1: テンプレート化されたワークフローを GitHub リポジトリに追加する

このタスクでは、次の一連の手順を使用して、テンプレート化されたワークフローを使用してプル要求を作成します。

- 「アクション」 タブに移動します。
- テンプレート Node.js ワークフローを選択します。
- ワークフローを新しいブランチにコミットします。
- ノードの CI というタイトルのプル要求を作成します。

1.  ラボ コンピューターで、Web ブラウザーを起動し、[GitHub アクション: 継続的インテグレーション ラボ](https://lab.github.com/githubtraining/github-actions:-continuous-integration)の起動ページに移動します。GitHub にまだサインインしていない場合は、右上隅にある 「**サインイン**」 をクリックします。
1.  「**GitHub ラーニング ラボ**」 ページで、「**GitHub ラーニング ラボで学習を開始**」 をクリックします。 
1.  [GitHub アクション: 継続的インテグレーション ラボ](https://lab.github.com/githubtraining/github-actions:-continuous-integration),の起動ページに戻り、「**無料コースの開始**」 をクリックします。
1.  ポップアップウィンドウで、**GitHub Learning Lab** が GitHub アカウントに **github-actions-for-ci** という名前のパブリック リポジトリを作成し、「**GitHub アクションの開始: 継続的インテグレーション**」 をクリックすることに注意してください。
1.  **GitHub アクション: 継続的インテグレーション**」 ページの起動ページに戻り、「**コース ステップ**」 のリストで、最初のステップ 「**テンプレートワークフローの使用**」 の横にある 「**開始**」 をクリックします。**github-actions-for-ci** リポジトリの 「**問題**」 タブに自動的にリダイレクトされます。
1.  **github-actions-for-ci** リポジトリの 「**問題**」 タブの 「**バグがあります**」 の問題ページで、「**ようこそ**」 セクションを確認します。 

    > **注**: 「**ようこそ**」 セクションによると、リポジトリのどこかにバグがあります。継続的インテグレーション (CI) の実践を使用して自動テストを設定し、このようなシナリオの発見、診断、および最小化を容易にします。コードベースは Node.js で書かれています。GitHub Actions を使用すると、Node.js などの一般的な言語やフレームワーク用にテンプレート化されたワークフローを使用できます。テンプレート化されたワークフローを使用してプル要求を作成します。

1.  「**バグがあります**」 ページで、「**アクション**」 トップ メニューのタブ ヘッダーをクリックします。 
1.  **github-actions-for-ci** リポジトリの 「**アクション**」 タブの 「**GitHub アクションの開始**」 ページの 「**Node.js**」 ペインで、「**このワークフローのセットアップ**」 をクリックします。
1.  **github-actions-for-ci/.github/workflows/node.js.yml** ページで、「**コミットの開始**」 をクリックします。
1.  「**新しいファイルのコミット**」 ペインで、このコミットの新しいブランチを作成するデフォルト設定を受け入れてプル要求を開始し、「**新しいファイルのコミット**」 をクリックします。
1.  「**プル要求を開く**」 「**ノード .js.yml の作成**」 ページで、プル要求の名前で、「**Create node.js.yml**」 の名前を 「**CI for Node**」 に変更し、「**プル要求の作成**」 をクリックします。

> **注**: テンプレート化されたワークフローをブランチに追加するだけで、GitHub アクションがリポジトリの CI を開始できます。 

#### タスク 2: テンプレート化されたワークフローを実行する

このタスクでは、テンプレート化されたワークフローの実行を追跡し、結果を確認します

1.  **github-actions-for-ci** GitHub リポジトリの**ノード #2 のCI** の 「**プル要求**」 タブで、プル要求の 「**会話**」 タブで、意図した変更を確認します。これは、**github/workflows/node.js.yml** ファイルの内容を表します。
1.  個々の変更を確認するときに、対応する 「**会話の解決**」 ボタンをクリックします。

    > **注**: **github/workflows/node.js.yml** ファイルには次のコンポーネントが含まれています。

    - ワークフロー: ワークフローは自動化の単位であり、自動化をトリガーするもの、自動化中に考慮すべき環境またはその他の側面、およびトリガーの結果として発生する必要があるものの定義が含まれます。
    - Job: ジョブは、1 つ以上のステップで構成されるワークフローのセクションです。サンプル ワークフローでは、テンプレートがビルド ジョブを形成するステップを定義します。
    - ステップ: ステップは、自動化の一部を表します。ステップは GitHub アクションとして定義できます。
    - アクション: GitHub アクションは、ワークフローと互換性のある方法で記述された自動化の一部です。GitHub から直接入手できる、オープンソース コミュニティから入手できる組み込みアクションを使用することも、カスタム アクションを作成することもできます。たとえば、**actions/checkout@v2** は、ビルドを実行している仮想マシンにコードベースのコピーがあることを確認するために使用されます。チェックアウトされたコードは、テストの実行に使用されます。複数のバージョンに対してテストを実行するため、アクション **actions/setup-node@v1** を使用して Node.js の適切なバージョンをセットアップします。

    > **注**: **github/workflows/node.js.yml** ファイルの **on:** フィールドは、GitHub アクションにいつ実行するかを指示します。この場合、プッシュがあるときはいつでもワークフローを実行しています。

    > **注**: **github/workflows/node.js.yml** ファイルの **jobs:** ブロックは、アクション ワークフローのコア コンポーネントを定義します。ワークフローはジョブで構成されており、テンプレート ワークフローは識別子 build を使用して単一のジョブを定義します。すべてのジョブには、実行する特定のホストマシンも必要です。これは、**runs-on:** フィールドの値で指定されます。このテンプレート ワークフローは、最新バージョンの Ubuntu を使用してビルド ジョブを実行しています。

    > **注**: ワークフローは、ビルド済みのアクションの実行に加えて、ビルドを実行している仮想マシンに直接アクセスする場合と同じように、コマンドを実行することもできます。テンプレート ワークフローの **run:** フィールドを使用すると、依存関係をインストールする **npm install** や、選択したテスト フレームワークを実行する **npm test** など、プロジェクトに関連する任意のコマンドを実行できます。

    ```yaml
    # このワークフローは、ノードの依存関係をクリーン インストールし、ソース コードをビルドし、ノードのさまざまなバージョンでテストを実行します
    # 詳細については、https://help.github.com/actions/language-and-framework-guides/using-nodejs-with-github-actions を参照してください。

    name: Node.js CI

    on:
      push:
        branches: [ master ]
      pull_request:
        branches: [ master ]

    jobs:
      build:

        runs-on: ubuntu-latest

        strategy:
          matrix:
            node-version: [10.x, 12.x, 14.x]

        steps:
        - uses: actions/checkout@v2
        - name: Use Node.js ${{ matrix.node-version }}
          uses: actions/setup-node@v1
          with:
            node-version: ${{ matrix.node-version }}
        - run: npm ci
        - run: npm run build --if-present
        - run: npm test
    ```

> **注**: ワークフローが失敗するという事実は無視してください。これは予測されていることです。失敗の理由を特定するには、リポジトリの 「**アクション**」 タブの内容を確認するか、プル要求の 「**会話**」 タブにリストされている失敗に対応する 「**詳細**」 リンクをクリックします。

> **注**: この場合、エラーの原因は **npm test** コマンドです。**npm test** コマンドは、テスト フレームワークを探します。このラボでは、Jest を使用します。Jest では、**\_\_test\_\_**.という名前のディレクトリで単体テストを行う必要があります。問題は、**\_\_test\_\_** ディレクトリがこのブランチに存在しないことです。

#### タスク 3: GitHub ワークフローに Jest テストを追加する

このタスクでは、Jest ベースのテストを GitHub ワークフローに追加して、次の手順を使用して、前のタスクで特定した障害に対処します。

- **Add Jest tests** という名前のオープンプル要求に移動します。
- プル要求をマージする

1.  **github-actions-for-ci** GitHub リポジトリの**ノード #2 のCI** ページで、「**プル要求**」 タブをクリックします。
1.  プル要求のリストで、「**jest テストの追加**」 をクリックします。
1.  「**jest テストの追加**」 ページで、プル要求の 「**会話**」 タブの内容を確認します。

    > **注**: このプル要求では、良く使用される JavaScript テスト フレームワークである Jest が導入されています。これを使用して、継続的インテグレーションに使用する方法を学習します。

1.  「**jest テストの追加**」 ページのプル要求の 「**会話**」 タブで、「**プル要求のマージ**」 をクリックしてから、「**マージの確認**」 をクリックします。
1.  「**jest テストの追加**」 ページのプル要求の 「**会話**」 タブで、**github-learning-lab** ボットからのコメントで 「**次のステップ**」 リンクをクリックします。これにより、**github-actions-for-ci** GitHub リポジトリの**ノード #2 の CI** プル要求の 「**会話**」 タブにリダイレクトされます。

#### タスク 4: アクション ログを確認して失敗したテストを特定する

このタスクでは、アクション ログを確認して、失敗したテストを特定します。 

> **注**: テスト フレームワークが適切に構成されたので、ビルド プロセスが自動的にそれを呼び出す必要があります。対応するログを確認して結果を判断します。次のステップを推奨します。以前と同様に、リポジトリの 「**アクション**」 タブ、またはプル要求の 「**会話**」 タブにリストされている失敗に対応する 「**詳細**」 リンクからログにアクセスできます。

このタスクを完了するには、次の一連の手順を使用します。

- ワークフロー ログに移動する
- 失敗したテストの名前を特定する
- 失敗したテストの名前を含むコメントを会話に追加する

1.  **github-actions-for-ci** GitHub リポジトリの**ノード #2 の CI** プル要求の 「**会話**」 タブに戻り、**github-learning-lab** ボットから 「**Waiting on tests**」 コメントまでスクロールして、その内容を確認します。
1.  「**会話**」 タブのコメントのリストまで下にスクロールし、失敗した個々のチェックの横にある各 「**詳細**」リ ンクをクリックします。これにより、**ノード #2 の CI** の 「**確認**」 タブに自動的にリダイレクトされます。
1.  **ノード #2 の CI** の 「**確認**」 タブで、各ビルド ログを確認し、**npm test の実行**中にすべてが失敗することを確認します。
1.  **npm test の実行**ステージを調べ、「**ゲーム**」 セクションで、失敗を示す **X** マークが付いている個々のテストの名前を特定します。

    ```
    FAIL __test__/game.test.js
      アプリ
        ✕ コンパイルされた JavaScript が含まれています (8 ミリ秒)
      ゲーム
        ゲーム
          ✕ 2 人のプレイヤーで初期化します (3 ミリ秒)
          ✓ 空のボードで初期化します (1 ミリ秒)
          ✕ ランダムなプレイヤーでゲームを開始します
        turn
          ✓ 上部中央に 'X' を挿入します
          ✓ 上部左に 'X' を挿入します
        nextPlayer
          ✕ 現在のプレイヤーをそうでない人に設定します (1 ミリ秒)
        hasWinner
          ✓ 行が塗りつぶされている場合に勝ちます (1 ミリ秒)
          ✓ 列が塗りつぶされている場合に勝ちます
          ✓ 左下の対角線が塗りつぶされている場合に勝ちます (1 ミリ秒)
          ✓ 右上の対角線が塗りつぶされている場合に勝ちます
    ```

1.  「**会話**」 タブに戻り、コメントのリストの一番下までスクロールし、最後のコメントの 「**書き込み**」 タブで、「**コメントを残す**」 を前の手順で特定した次の名前に置き換えて、「**コメント**」 をクリックします。

    ```
    2 人のプレイヤーで初期化する
    ランダム プレイヤーでゲームを開始する
    現在のプレイヤーをそうでない人に設定する
    ```

> **注**: これにより、「**失敗したログの読み取り**」コメントから始めて、ボットからの別のコメント セットが 「**会話**」 タブに自動的に表示されます。

#### タスク 5: 失敗したテストを修正する

このタスクでは、問題を修正するために、テストが失敗する原因となっているファイルを変更します。

> **注**: 失敗したテストの 1 つは次のとおりです。2人のプレイヤーで初期化します。ログをさらに詳しく調べてみると、単体テストでは 2 人のプレイヤーの名前がセーラムとネイトであることが期待されていることに気付くかもしれませんが、どういうわけかネイトの代わりにバナナが使用されました：

    ```
      ● ゲーム › ゲーム › ランダム プレイヤーでゲームを開始する

        expect(received).toBe(expected) // Object.is equality

        Expected: "Nate"
        Received: "Bananas"

          39 | 
          40 |       Math.random = () => 0.6
        > 41 |       expect(new Game(p1, p2).player).toBe('Nate')
             |                                       ^
          42 |     })
          43 |   })
          44 | 
    ```

> **注**: テスト ファイルにテストするコードファイルと同じ名前を付け、.test.js 拡張子を追加するのが一般的な方法です。game.test.js のテスト結果は、game.js の問題が原因であると推測できます。

1.  **github-actions-for-ci** GitHub リポジトリの**ノード #2 の CI** プル要求の 「**会話**」 タブで、**github-learning-lab** ボットからの最新のコメントを見つけてその内容を確認します。
1.  コメントで参照されているコードの変更を特定するには、「**変更の表示**」 ボタンをクリックし、**\_\_test\_\_/game.test.js** ファイルを表すセクションまでスクロールして、提案された変更を確認します。

    ```yaml
    Suggested change 
        this.p2 = 'Bananas'
        this.p2 = p2
    ```

1.  **github-actions-for-ci** GitHub リポジトリの**ノード #2 の CI** プル要求の 「**会話**」 タブに戻り、**github-learning-lab** ボットから最新のコメントまでスクロールダウンし、「**提案のコミット**」 をクリックして、ポップアップ ペインで 「**変更のコミット**」 をクリックします。

    > **注**: 変更をコミットすると、テストが再度実行され、今回は正常に完了します。 

1.  **github-actions-for-ci** GitHub リポジトリの**ノード #2 の CI** プル要求の 「**会話**」 タブで、「**承認された変更**」 応答まで下にスクロールし、「**プル要求のマージ**」 をクリックしてから、「**マージの確認**」 をクリックします。 
1.  **github-actions-for-ci** GitHub リポジトリの**ノード #2 の CI** プル要求の 「**会話**」 タブで、**github-learning-lab** ボットからの最新のコメントで 「**次のステップ**」 リンクをクリックします。これにより、**チーム #4 全体のワークフロー**を表示する 「**問題**」 タブにリダイレクトされます。

#### タスク 6: 次のステップを確認する

このタスクでは、最初のワークフローを共有してチーム全体で使用できるようにする次のステップを確認します。

> **注**: CI の設定方法を学習したので、より現実的なユースケースを試してみましょう。あなたのチームには、これまで使用してきたテンプレートを超えるカスタム ワークフローがあります。次の機能が必要です。

- オペレーティング システムと Node.js バージョンのさまざまな組み合わせを検証できるように複数のターゲットに対してテストする機能
- ビルドをテストの詳細から分離できるようにするための専用のテスト ジョブ
- ターゲット環境にアーティファクトをデプロイし、アーティファクトをビルドするためにアクセスすること。
- マスター ブランチが削除されたり、誤って破損したりしないようにするためのブランチ保護
- チームメートがプル要求を再確認できるようにするために必要なレビュー
- 迅速にマージし、マージとデプロイを自動化できる明確な承認

#### タスク 7: カスタム GitHub アクション ワークフローを作成する

このタスクでは、カスタム GitHub アクション ワークフローを作成します。

この機能を実装するには、次の一連の手順を実行します。

- 新しいブランチで既存のワークフローファイルを編集する
- ワークフロー ファイルで、ノードのバージョン 12.x および 14.x をターゲットにする
- 変更を含む **CI の改善**という名前の新しいプル要求を開く

1.  **チーム #4 全体のワークフロー** ページを表示するリポジトリ **github-actions-for-ci** の「**問題**」 タブで、「**ステップ7：カスタム GitHub アクション ワークフローを作成する**」というラベルの付いたセクションまでスクロールし、「**アクティビティ: 新しいビルドターゲットで既存のワークフローを編集する**」 リストを含むワークフローで、**既存のワークフロー**リンクをクリックします。これにより、リポジトリ **github-actions-for-ci** の「**コード**」 タブにある **github-actions-for-ci/.github/Workflows/node.js.yml** ファイルの 「**ファイルの編集**」 ビューにリダイレクトされます。
1.  **github-actions-for-ci/.github/workflows/node.js.yml** ファイルで、`node-version: [10.x, 12.x, 14.x]` を `node-version: [12.x, 14.x]` に置き換えます。
1.  **github-actions-for-ci** リポジトリの 「**コード**」 タブの右上隅にある 「**コミットの開始**」 をクリックします。
1.  「**変更のコミット**」 ペインで、このコミットの新しいブランチを作成するデフォルト設定を受け入れてプル要求を開始し、「**変更のコミット**」 をクリックします。
1.  「**プル要求を開く**」 ページで、プル要求の名前で 「**Update node.js.yml**」 の名前を 「**Improve CI**」 に変更し、「**プル要求の作成**」 をクリックします。これにより、**github-actions-for-ci** リポジトリの 「**プル要求**」 タブの 「**CI #5 の作成**」 ページに自動的にリダイレクトされます。

> **注**: ノードの特定のバージョンを対象とすることで、複数のオペレーティング システム、プラットフォーム、および言語バージョンにわたるテストを可能にするビルド マトリックスを構成しました。このトピックの詳細については、[GitHub Docs](https://help.github.com/en/articles/configuring-a-workflow#configuring-a-build-matrix) を参照してください。

#### タスク 8: Windows 環境を対象にする

このタスクでは、ワーク フローファイルを編集して Windows 環境用にビルドします

> **注**: アプリの Windows 環境へのデプロイをサポートしたいので、マトリックス ビルド構成に Windows を追加しましょう。

この機能を実装するには、次の一連の手順を実行します。

- **os** フィールドをワークフローの **strategy.matrix** セクションに追加する
- **ubuntu-latest** と **windows-2016** をターゲット オペレーティング システムのリストに追加する
- ワークフローの変更を既存のブランチにコミットする

    ```yaml
    node-version: [10.x, 14.x]
    os: [ubuntu-latest, windows-2016]
    node-version: [12.x, 14.x]
    ```

1.  **github-actions-for-ci** リポジトリの 「**プル要求**」 タブの 「**CI #5 の改善**」 ページで、**github-learning-lab** ボットから最新のコメントまでスクロールし、その内容を確認します。
1.  「**アクティビティ: Windows 環境用にビルドするワークフローファイルを編集する**」 セクションで、ステップ 1 の**github/workflows/nodejs.yml** リンクをクリックします。  これにより、リポジトリ **github-actions-for-ci** の「**コード**」 タブにある **github-actions-for-ci/.github/Workflows/node.js.yml** ファイルの 「**ファイルの編集**」 ビューにリダイレクトされます。
1.  **github-actions-for-ci/.github/workflows/node.js.yml** ファイルで、マトリックス セクションを確認し、行われる変更を特定します。 
1.  「**アクティビティ: ワークフローファイルを編集して Windows 環境用にビルドする**」 セクションに戻り、**github-actions-for-ci** リポジトリの 「**プル要求**」 タブの 「**CI #5 の改善**」 ページで、「**提案のコミット**」 をクリックし、ポップ アップ ペインで「**変更のコミット**」 をクリックします。
1.  これにより、**github-actions-for-ci** リポジトリの 「**プル要求**」 タブの 「**CI #5 の改善**」 ページのコンテンツが、**新しいジョブ**というラベルの付いた **github-learning-lab** ボットからの最新のコメントで更新されます。

> **注**: ログを確認すると、この時点で 4 つのビルドがあることがわかります。これは、2 つのオペレーティング システムのそれぞれについて、2 つのバージョンに対してテストを実行しているためです。

#### タスク 9: 複数のジョブを構成する

このタスクでは、ワークフロー ファイルを編集して、ビルド ジョブとテスト ジョブを分離します。

> **注**: 次に、専用のテスト ジョブを作成しましょう。これにより、ワークフローのビルド機能とテスト機能を、ワークフローがトリガーされたときに実行される複数のジョブに分割できます。

1.  **github-actions-for-ci** リポジトリの 「**プル要求**」 タブの 「**CI #5 の改善**」 ページで、「**新しいジョブ**」 というラベルの付いた **github-learning-lab** ボットからの最新のコメントで、「**ステップ9: 複数のジョブを使用する**」 セクションで、ステップ 1 の**ワークフロー ファイル**のリンクをクリックします。  これにより、ブラウザーは、リポジトリ **github-actions-for-ci** の「**コード**」 タブにある **github-actions-for-ci/.github/Workflows/node.js.yml** ファイルの 「**ファイルの編集**」 ビューにリダイレクトされます。
1.  ビルド ジョブ セクションで、既存のワークフローを表す次のコンテンツを追加します：

    ```yaml
    build:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v2
        - name: npm install and build webpack
          run: |
            npm install
            npm run build
    ```

1.  **github-actions-for-ci/.github/workflows/node.js.yml** ファイルの一番下に、次の内容で、**test** という名前のジョブを表す新しいエントリを追加します (そのインデントがビルド ジョブ エントリと一致することを確認してください)。

    ```yaml
    test:
      runs-on: ubuntu-latest
      strategy:
        matrix:
          os: [ubuntu-latest, windows-2016]
          node-version: [12.x, 14.x]
      steps:
      - uses: actions/checkout@v2
      - name: Use Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v1
        with:
          node-version: ${{ matrix.node-version }}
      - name: npm install, and test
        run: |
          npm install
          npm test
        env:
          CI: true
    ```

1.  これにより、次のコンテンツが生成されます。

    ```yaml
    name: Node CI

    on: [push]

    jobs:
      build:

        runs-on: ubuntu-latest

        steps:
          - uses: actions/checkout@v2
          - name: npm install and build webpack
            run: |
              npm install
              npm run build

      test:

        runs-on: ubuntu-latest

        strategy:
          matrix:
            os: [ubuntu-latest, windows-2016]
            node-version: [12.x, 14.x]

        steps:
        - uses: actions/checkout@v2
        - name: Use Node.js ${{ matrix.node-version }}
          uses: actions/setup-node@v1
          with:
            node-version: ${{ matrix.node-version }}
        - name: npm install, and test
          run: |
            npm install
            npm test
          env:
            CI: true
    ```

1.  編集中の **github-actions-for-ci/.github/workflows/node.js.yml** ファイルのコンテンツを表示するリポジトリ **github-actions-for-ci** の 「**コード**」 タブで、右上隅にある 「**コミットの開始**」 をクリックします。
1.  「**変更のコミット**」 ペインで、現在のブランチに直接変更をコミットするデフォルト設定を受け入れ、「**変更のコミット**」 をクリックします。

> **注**: このコミットに続いて、ワークフローが再度実行されます。 

#### タスク 10: 複数のジョブを実行する
 
このタスクでは、ワークフロー内の複数のジョブの結果を待つだけです。

> **注**: このタスクでは、アクションは必要ありません。 

#### タスク 11: ジョブのビルド アーティファクトをアップロードする

このタスクでは、ワークフロー ファイルのアップロード アクションを使用して、ジョブのビルド アーティファクトを保存します。

> **注**: ビルドは成功したが、各テストジョブは失敗したことに気付く場合があります。これは、各ジョブが仮想環境の新しいインスタンスで実行されるため、ビルドで作成されたビルド アーティファクトをテスト ジョブで使用できないためです。これは、仮想環境の設計に固有の部分です。これに対処するために、組み込みのアーティファクト ストレージを使用して、あるジョブから作成されたアーティファクトを保存し、同じワークフロー内の別のジョブで使用できます。アーティファクトを使用すると、ジョブの完了後にデータを永続化し、同じワークフロー内の別のジョブとそのデータを共有できます。アーティファクトは、ワークフローの実行中に生成されたファイルまたはファイルのコレクションです。

> **注**: アーティファクトをアーティファクト ストレージにアップロードするには、GitHub によってビルドされたアクション actions/upload-artifacts を使用できます。

1.  **github-actions-for-ci** GitHub リポジトリの 「**CI #5 の改善**」 ページの 「**プル要求**」 タブに戻り、「**会話**」 タブで、**github-learning-lab** ボットからの最新のコメントまでスクロールしてその内容を確認します。
1.  **github-actions-for-ci** リポジトリの 「**プル要求**」 タブの 「**CI #5 の改善**」 ページで、「**新しいジョブ**」 というラベルの付いた **github-learning-lab** ボットからの最新のコメントで、「**ステップ11: ジョブのビルド アーティファクトをアップロードする**」 セクションの、手順 1 で**ワークフロー ファイル**のリンクをクリックします。これにより、ブラウザーは、リポジトリ **github-actions-for-ci** の「**コード**」 タブにある **github-actions-for-ci/.github/Workflows/node.js.yml** ファイルの 「**ファイルの編集**」 ビューにリダイレクトされます。
1.  ビルド ジョブ セクションで、ビルド ジョブを更新して、**upload-artifacts** アクションを含め、次のコンテンツと一致するようにします：

    ```yaml
      build:
        runs-on: ubuntu-latest
        steps:
          - uses: actions/checkout@v2
          - name: npm install and build webpack
            run: |
              npm install
              npm run build
          - uses: actions/upload-artifact@master
            with:
              name: webpack artifacts
              path: public/
    ```

1.  編集中の **github-actions-for-ci/.github/workflows/node.js.yml** ファイルのコンテンツを表示するリポジトリ **github-actions-for-ci** の 「**コード**」 タブで、右上隅にある 「**コミットの開始**」 をクリックします。
1.  「**変更のコミット**」 ペインで、現在のブランチに直接変更をコミットするデフォルト設定を受け入れ、「**変更のコミット**」 をクリックします。

> **注**: このコミットに続いて、ワークフローが再度実行されます。 

#### タスク 12: ジョブのビルド アーティファクトをダウンロードする

このタスクでは、ワークフロー ファイルのダウンロード アクションを使用して、前のジョブのビルド アーティファクトにアクセスします。

> **注**: ビルド アーティファクトはアーティファクト ストレージにアップロードされますが、ワークフローを追跡する場合は、テスト ジョブがまだ失敗していることに気付くでしょう。これには 2 つの主な理由があります。

- 順次実行するように明示的に構成されていない限り、ジョブは並行して実行されます。
- 各ジョブは独自の仮想環境で実行されるため、アーティファクトをストレージにプッシュしましたが、テスト ジョブはそれらを取得する必要があります。

> **注**: これを修正するには、ビルドが終了した後にのみテストを実行して、アーティファクトを使用できるようにします。さらに、アーティファクトを指定されたアーティファクト ストアにコピーし、アップロード アクションを活用するために、別の GitHub 組み込みアクション **actions/download-artifact** を使用して、これらのアーティファクトをダウンロードします。

1.  **github-actions-for-ci** GitHub リポジトリの 「**CI #5 の改善**」 ページの 「**プル要求**」 タブに戻り、「**会話**」 タブで、**github-learning-lab** ボットからの最新のコメントまでスクロールしてその内容を確認します。
1.  **github-actions-for-ci** リポジトリの 「**プル要求**」 タブの 「**CI #5 の改善**」 ページで、「**新しいジョブ**」 というラベルの付いた **github-learning-lab** ボットからの最新のコメントで、「**ステップ12: **「**ジョブのビルド アーティファクトをダウンロードする**」 セクションの、手順 1 で**ワークフロー ファイル**のリンクをクリックします。これにより、ブラウザーは、リポジトリ **github-actions-for-ci** の「**コード**」 タブにある **github-actions-for-ci/.github/Workflows/node.js.yml** ファイルの 「**ファイルの編集**」 ビューにリダイレクトされます。
1. テスト ジョブ セクションで、次のコンテンツと一致するように、**needs: build** コンポーネントを追加して、ビルド ジョブが完了した後にのみ実行されるようにテスト ジョブを更新します。

    ```yaml
    test:
      needs: build
      runs-on: ubuntu-latest
    ```

1.  ビルド ジョブ セクションで、ビルド ジョブを更新して、次のコンテンツと一致するように、**download-artifacts** アクションを含めます。

    ```yaml
    steps:
    - uses: actions/checkout@v2
    - uses: actions/download-artifact@master
      with: 
        name: webpack artifacts
        path: public
    - name: Use Node.js ${{ matrix.node-version }}
      uses: actions/setup-node@v1
      with:
        node-version: ${{ matrix.node-version }}
    - name: npm install, and test
      run: |
        npm install
        npm test
      env:
        CI: true
    ```

1.  編集中の **github-actions-for-ci/.github/workflows/node.js.yml** ファイルのコンテンツを表示するリポジトリ **github-actions-for-ci** の 「**コード**」 タブで、右上隅にある 「**コミットの開始**」 をクリックします。
1.  「**変更のコミット**」 ペインで、現在のブランチに直接変更をコミットするデフォルト設定を受け入れ、「**変更のコミット**」 をクリックします。

> **注**: このコミットに続いて、ワークフローが再度実行されます。 

> **注**: カスタム ワークフローは、次の機能を提供するようになりました。

- サポートされているオペレーティング システムと Node.js バージョンが機能しているかどうかを確認するために、複数のターゲットに対してテストすること
- ビルドをテストの詳細から分離できるようにするための専用のテスト ジョブ
- ターゲット環境にアーティファクトをデプロイし、アーティファクトをビルドするためにアクセスすること。

#### タスク 13: 改善された CI ワークフローをチームと共有する

このタスクでは、プル要求と改善されたワークフローをマスター ブランチにマージします。

1.  **github-actions-for-ci** GitHub リポジトリの 「**CI #5 の改善**」 ページの 「**プル要求**」 タブに戻り、「**会話**」 タブで、**github-learning-lab** ボットからの最新のコメントまでスクロールしてその内容を確認します。
1.  **github-actions-for-ci** リポジトリの 「**プル要求**」 タブの 「**CI #5 の改善**」 ページで、「**CI のマージ**」 というラベルの付いた **github-learning-lab** ボットからの最新のコメントで、「**ステップ13: 改善された CI ワークフローをチームと共有する**」 セクションを確認します。

    > **注**: これまでに実装した要件のリストのステータスは次のとおりです。

    - サポートされているオペレーティング システムと Node.js バージョンが機能しているかどうかを確認するために、複数のターゲットに対してテストすること
    - ビルドをテストの詳細から分離できるようにするための専用のテスト ジョブ
    - ターゲット環境にアーティファクトをデプロイし、アーティファクトをビルドするためにアクセスすること。

    > **注**: 次のいくつかのステップでは、チームのワークフローに次の機能を提供する変更を加えます。

    - マスター ブランチが削除されたり、誤って破損したりしないようにするためのブランチ保護
    - チームメートがプル要求を再確認するために必要なレビュー
    - 迅速にマージし、マージとデプロイを自動化できる明確な承認

1.  「**承認済みの変更**」 セクションまでスクロールし、「**プル要求のマージ**」 をクリックしてから、「**マージの確認**」 をクリックします。

#### タスク 14: レビュー プロセスを自動化する

このタスクでは、チームのレビュー プロセスを自動化するために、新しいワークフロー ファイルを追加します。

1.  **github-actions-for-ci** リポジトリの 「**プル要求**」 タブの 「**CI #5 の改善**」 ページで、**github-learning-lab** ボットからの最新のコメントで 「**次のステップ**」 リンクをクリックします。これにより、**カスタム ワークフロー #6** という名前のプル要求の 「**会話**」 タブにリダイレクトされます。
1.  **カスタム ワークフロー #6** プル要求の 「**会話**」 タブで、下にスクロールして、「**ステップ 14: レビュープ ロセスを自動化する**」 というラベルの付いたセクションを確認します。

    > **注**: GitHub アクションは、さまざまなイベント トリガーに対して複数のワークフローを実行できます。Node.js ワークフローと連携する新しい承認ワークフローを作成しましょう。

1.  「**アクティビティ: 新しいワークフロー ファイルを追加してチームのレビュー プロセスを自動化する**」 というラベルの付いたセクションで、アクションのリストで、手順 1 の 「**新しいファイル**」 リンクをクリックします。これにより、**github-actions-for-ci** リポジトリの 「**コード**」 タブにリダイレクトされ、**github-actions-for-ci/.github/Workflows/approval-workflow.yml** ファイルが開いた状態のエディター ページが表示されます。
1.  エディター ペイン内で、`name: AZ-400 Team approval workflow` と入力し、ページの一番下までスクロールして、「**新しいファイルのコミット**」 をクリックします。

#### タスク 15: アクションを使用してプル要求のレビューを自動化する

このタスクでは、新しいワークフローでコミュニティ アクションを使用します

> **注**: ワークフローは、以下を実行するように構成できます。

- GitHub からのイベントの使用
- スケジュールされた時間
- GitHub の外部のイベントが発生したとき

> **注**: これまで、Node.js ワークフローにプッシュ イベントを使用してきました。これは、リポジトリへのコード変更に対してアクションを実行する場合に意味があります。レビュー ワークフローでは、人間によるレビューを行いたいと考えています。たとえば、承認済みのプル要求のラベル付けアクションを使用して、プル要求をマージするのに十分なレビューを取得したことを簡単に確認できるようにします。**pull_request_review** イベントでトリガーして、レビュー ワークフローを準備しましょう。

1.  プル要求**カスタム ワークフロー #6** の 「**会話**」 タブに戻り、**github-learning-lab** ボットからの最新のコメントまでスクロールし、その内容を確認します。
1.  **github-actions-for-ci** リポジトリの 「**プル要求**」 タブの 「**カスタム ワークフロー #6**」 というラベルの付いたページで、**github-learning-lab** ボットからの最新のコメントで、「**ステップ15: アクションを使用してプル要求のレビューを自動化する**」 セクションを確認します。
1.  このステップでは、前のステップで作成したワークフロー ファイルに **pull_request_review** を追加するだけでよいことに注意してください。
1.  「**ステップ 15: アクションを使用してプルリクエストレビューセクションを自動化する**」セクション内で、「**提案のコミット**」 をクリックし、ポップアップ ペインで 「**変更のコミット**」 をクリックします。

#### タスク 16: 新しいワークフローで承認ジョブを作成する

このタスクでは、新しいワークフロー ファイルで、コミュニティ アクションを使用する新しいジョブを作成します。

1.  プル要求 **カスタムワークフロー #6** の 「**会話**」 タブで、**github-learning-lab** ボットからの最新のコメントまでスクロールし、その内容を確認します。
1.  **github-actions-for-ci** リポジトリの 「**プル要求**」 タブの 「**カスタム ワークフロー #6**」 ページで、**github-learning-lab** ボットからの最新のコメントで、「**ステップ16: 新しいワークフローで承認ジョブを作成する**」 セクションを確認します。
1.  このステップでは、前のタスクで変更した同じワークフローファイルに、**labelWhenApproved** という名前の新しいジョブを次の形式で追加する必要があることに注意してください。

    ```yaml
    jobs:
      labelWhenApproved:
        runs-on: ubuntu-latest
    ```

1.  「**ステップ 16: 新しいワークフローで承認ジョブを作成する**」セクション内で、「**提案のコミット**」をクリックして、ポップアップ ペインで 「**変更のコミット**」 をクリックします。

#### タスク 17: 承認の自動化

このタスクでは、コミュニティ アクションを使用して、レビュー承認プロセスの一部を自動化します。

> **注**: 前のタスクでは、**labelWhenApproved** 識別子を使用してジョブを作成しました。ここで、**pullreminders/label-when-approved-action** という名前のコミュニティ作成アクションを使用します。このアクションは、事前設定された数の承認後に、プル要求にラベルを追加します。これらのラベルは、何かをマージする準備ができていることをチームに視覚的に示すために使用できます。また、他のアクションやツールを使用して、必要な数の承認を受け取ったときにプル要求を自動的にマージする方法としても使用できます。

1.  プル要求 **カスタムワークフロー #6** の 「**会話**」 タブで、**github-learning-lab** ボットからの最新のコメントまでスクロールし、その内容を確認します。
1.  **github-actions-for-ci** リポジトリの 「**プル要求**」 タブの 「**カスタム ワークフロー #6**」 ページで、**github-learning-lab** ボットからの最新のコメントで、「**ステップ17: 承認の自動化**」 セクションを確認します。

    > **注**: これを実装するには、次のガイドラインを使用します。

    - ワークフロー ファイルには、**steps:** ブロックが必要です
    - ステップ名は任意です
    - コミュニティ アクションを使用するには、**uses:** キーワードを含めます
    - **label-when-approved-action** には、次の環境変数を持つ **env:** という名前のブロックが必要です。
       - **APPROVALS** は、ラベルを適用するために必要な承認の数です。このラボでは、**1** に設定します。
       - アクションでラベルを作成してこのリポジトリに適用できるようにするには、**GITHUB_TOKEN** が必要です。 
       - **ADD_LABEL** は、承認の数に達したときに追加する必要があるラベルの名前です。その名前は任意です。

1.  **github-actions-for-ci** リポジトリの 「**コード**」 タブに切り替え、ブランチのリストで、**team-workflow** エントリを選択し、フォルダーのリストで、**github /workflows** をクリックし、「**approval-workflow.yml**」 をクリックし、**github-actions-for-ci/.github/workflows/approval-workflow.yml** のコンテンツを表示しながら、コードペインの右側にある鉛筆アイコンをクリックして編集モードに入ります。
1.  次のコンテンツを **approval-workflow.yml** ファイルに追加します。

    ```yaml
    steps:
    - name: Label when approved
      uses: pullreminders/label-when-approved-action@master
      env:
        APPROVALS: "1"
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        ADD_LABEL: "approved"
    ```

1.  「**コミットの開始**」 をクリックします。
1.  「**変更のコミット**」 ペインで、現在のブランチに直接変更をコミットするデフォルト設定を受け入れ、「**変更のコミット**」 をクリックします。

#### タスク 18: ブランチ保護を使用する

このタスクでは、マスター ブランチを保護することにより、自動レビュー プロセスを完了します。

> **注**: 保護されたブランチにより、リポジトリの共同編集者がブランチに取り消せない変更を加えることができなくなります。保護されたブランチを有効にすると、必要なステータ スチェックや必要なレビューなど、他のオプションのチェックと要件を有効にすることもできます。

1.  プル要求**カスタム ワークフロー #6** の 「**会話**」 タブに戻り、**github-learning-lab** ボットからの最新のコメントまでスクロールし、その内容を確認します。
1.  **github-actions-for-ci** リポジトリの 「**プル要求**」 タブの 「**カスタム ワークフロー #6**」 というラベルの付いたページで、**github-learning-lab** ボットからの最新のコメントで、「**ステップ18: ブランチ保護を使用する**」 セクションを確認します。
1.  ページの一番上までスクロールして戻り、トップ メニューで 「**設定**」 ヘッダーをクリックし、左側の垂直メニューで 「**ブランチ**」 をクリックします。
1.  「**ブランチ保護ルール**」 セクションで、「**ルールの追加**」 をクリックします。
1.  **ブランチ保護ルール**の**ブランチ名パターン**タイプ**マスター**で、**一致するブランチを保護する**設定リストで、「**マージする前にプル要求のレビューを要求する**」、「**マージする前にステータスチェックに合格する必要がある**」を有効にし、ビルド ジョブとテスト ジョブのそれぞれの横にあるチェックボックスを選択し、ページの一番下までスクロールして、「**作成**」 をクリックします。
1.  プル要求**カスタム ワークフロー #6** の 「**会話** 」 タブに戻り、**github-learning-lab** ボットの最新のコメントまでスクロールし、**ステップ 18: ブランチ保護を使用する**」 セクションを確認し、「**アクティビティ: マスターブランチサブセクションを保護して自動レビュープロセスを完了する**」サブセクションのステップ 8 で、「**要求されたレビューを承認する**」 リンクをクリックします。これにより、ブラウザー セッションが**カスタム ワークフロー** プル要求の 「**変更されたファイル**」 タブにリダイレクトされます。
1.  **カスタム ワークフロー** プル要求の 「**変更されたファイル**」 タブで、「**変更のレビュー**」 をクリックし、「**承認**」 オプションを選択して、「**レビューの送信**」 をクリックします。これにより、ブラウザー セッションが **github-actions-for-ci** リポジトリの 「**プル要求**」 タブの 「**カスタム ワークフロー #6**」 というラベルの付いたページにリダイレクトされ、**github-learning-lab** ボットからの最新のコメントが表示され、ワークフローが正常に完了したことを確認します。

## レビュー

このラボでは、ビルド プロセスを自動化する GitHu bワークフローを設定する方法を学びました。
